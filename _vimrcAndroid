" vim:set ts=4 sts=4 sw=4 tw=0:
let g:skip_defaults_vim = 1
"	そもそもファイルが存在しないので読み込まない。
"
"	.vimrcなどの場所(macVim版)
"		https://qiita.com/gam0022/items/87491e8a32a5926684d2
"		https://vim-jp.org/vimdoc-ja/starting.html#initialization

" vimScriptの変数スコープ
"	b:	現在のバッファ限定
"	w:	現在のウィンドウ限定
"	t:	現在のタブページ限定
"	g:	グローバル
"	l:	関数限定
"	s:	sourceされたvimScript限定
"	a:	関数の引数として、関数内限定
"	v:	グローバルとしてvimがあらかじめ定義済み。

"	シンタックスハイライト有効化
"syntax off
"syntax clear
"syntax reset
"syntax on
"colorscheme elflord
colorscheme torte	" gvimrcへの設定をこちらに移した

"
"	リーダーキー
"	<Leader>	デフォルトではバックスラッシュ
"	現在はスペースキーに割り当てている。
let mapleader = "\<Space>"

" ステータスラインに文字コードを表示させる。
set statusline=%<%f\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c%V%8P


"	ーーーパッケージ管理20190622ーーー
"	git clone https://github.com/k-takata/minpac ~/.vim/pack/develop/opt/minpac
"	※ディレクトリは、あらかじめ作成しておくこと。
" [asakunotomohiro@Qiita minpac] $ pwd
" /Users/asakunotomohiro/.vim/pack/develop/opt/minpac
" [asakunotomohiro@Qiita minpac] $ ls -R1 ../../../..
" ../../../../dict:
" ../../../../pack:	←作成
" ../../../../pack/develop:	←作成
" ../../../../pack/develop/opt:	←作成
" ../../../../pack/develop/opt/minpac:
" ../../../../pack/develop/opt/minpac/autoload:
" ../../../../pack/develop/opt/minpac/autoload/minpac:
" ../../../../pack/develop/opt/minpac/doc:
" ../../../../pack/develop/opt/minpac/plugin:
" ../../../../pack/develop/opt/minpac/test:
" ../../../../pack/develop/opt/minpac/tools:
" ../../../../pack/develop/start:	←作成
" ../../../../writing:	←作成
" ../../../../writing/opt:	←作成
" ../../../../writing/start:	←作成
"	更新コマンド：:call minpac#update()
"			削除：:call minpac#clean()
"			情報：:call minpac#status()

if ( has('win32') || has('win64') )
	"set packpath?
	"set runtimepath?
	set runtimepath^=~/.vim,~/.vim/pack,~/.vim/after
	set packpath^=~/.vim

"	set path+=&runtimepath
endif

let minpackOPT = "$HOME/.vim/pack/minpac/opt/"
let minpackSTART = "$HOME/.vim/pack/minpac/start/"

if isdirectory(expand(minpackSTART . "minpac"))  || isdirectory(expand(minpackOPT . "minpac"))
packadd minpac
endif
if !exists('g:loaded_minpac')
  " minpacがロードされていない場合の処理。
else
  " minpac がロードされている場合
call minpac#init()

" minpacでminpacを更新する場合は以下を有効にする。
call minpac#add('k-takata/minpac', {'type': 'opt'})

call minpac#add('previm/previm', {'type': 'opt'})	" プレビュー用
call minpac#add('tyru/open-browser.vim', {'type': 'opt'})	" ブラウザを起動し、上記のprevimを表示させる。

"let s:lazy_plugs = [
"	\ ['previm/previm', {'type': 'opt'}],
"	\ ['tyru/open-browser.vim', {'type': 'opt'}],

"	\ ['mattn/vim-lsp-settings', {'type': 'opt'}],
"	\ ['mattn/vim-goimports', {'type': 'opt'}],
"	\ ['thomasfaingnaert/vim-lsp-snippets', {'type': 'opt'}],

"	\ ['itchyny/calendar.vim', {'type': 'opt'}],
"	\ ]

" IDE用の設定プラグイン？
"call minpac#add('tpope/vim-vinegar')	" エクスプローラの補助的な枠割り？
	" I：メニュー表示・~：ホームディレクトリ移動
"let NERDTreeHijackNetrw = 0
call minpac#add('prabirshrestha/async.vim')
call minpac#add('prabirshrestha/asyncomplete.vim')	" 自動補完補助
call minpac#add('prabirshrestha/vim-lsp')	" 挙動不審？
call minpac#add('mattn/vim-lsp-settings')
"	個々のインストール先：%LOCALAPPDATA%\vim-lsp-settings\servers
"	以下のコマンドを打つことにより、プログラムファイルに応じたファイルがインストールされる。
"	LspInstallServer
"	・環境構築が整っていない場合に出るメッセージのようだ。
"		efm-langserver requires go
call minpac#add('mattn/vim-goimports', {'type': 'opt'})	" インポート用：GoImport
"	go get golang.org/x/tools/cmd/goimports		←このコマンドがインストールされていなければ、プラグインによるインポートが行われない。

call minpac#add('thomasfaingnaert/vim-lsp-snippets')
call minpac#add('thomasfaingnaert/vim-lsp-neosnippet')
" 以下、依存3点
"call minpac#add('Shougo/neosnippet.vim')
"call minpac#add('Shougo/neosnippet-snippets')
"call minpac#add('prabirshrestha/vim-lsp')

" 以下、Pythonがなければ動かない。
"call minpac#add('SirVer/ultisnips')

" 以下は、vimScriptのみで動く。
"call minpac#add('hrsh7th/vim-vsnip')
"call minpac#add('hrsh7th/vim-vsnip-integ')
"	スニペット用ファイルさえ用意できれば使えそうな感じがする。

" 以下、Python設定が必要。
"call minpac#add('Shougo/deoppet.nvim')

"	スニペット用プラグイン。
"		Android版では動かさない。
"call minpac#add('drmingdrmer/xptemplate', {'type': 'opt'})
"		動かし方：<C-\>

"	シンタックスチェック
call minpac#add('vim-syntastic/syntastic')

"	オートコンプリートポップアップメニュー表示
call minpac#add('prabirshrestha/asyncomplete.vim')
"		オートコンプリートソース
call minpac#add('prabirshrestha/asyncomplete-lsp.vim')	" 自動補完補助

" Go言語用プラグイン
"call minpac#add('https://github.com/fatih/vim-go')
"	複雑な設定が必要になるため、手に余る。
"	しかし、慣れれば使い勝手はよくなるはず。

"	vimスクリプト用のランゲージサーバ
"call minpac#add('iamcco/vim-language-server')	" 導入されないようだ。

call minpac#add('tpope/vim-commentary', {'type': 'opt'})	" コメント化
autocmd BufNewFile,BufRead *.sh setlocal commentstring=#\	%s
"autocmd BufNewFile,BufRead *.sh setlocal commentstring=#\ %s
autocmd BufNewFile,BufRead [._g]{,2}vimrc setlocal commentstring=\"\	%s
"autocmd BufNewFile,BufRead [._g]{,2}vimrc setlocal commentstring=\"\ %s

" 動かない。動いてはいるようだが、可視化してくれない。
"call minpac#add('nathanaelkane/vim-indent-guides')	" インデントの可視化
"call minpac#add('Yggdroot/indentLine')	" インデントの可視化
"	半角スペースでなければ意味ないようだ。Tabにはできそうにない。

" ファイル検索？エクスプローラ？
"	Ctrl+P	←これで起動する。
call minpac#add('ctrlpvim/ctrlp.vim')
"		検索モードの切り替え：Ctrl+F
"		下方向のカーソル移動：Ctrl+J
"		上方向のカーソル移動：Ctrl+K
"		検索結果の選択(開く)：Enter
"		　　　々　(水平分割)：Ctrl+X
"		CtrlPの終了　　　　 ：Esc

" migemo：ローマ字のまま日本語をインクリメンタル検索
"call minpac#add('koron/cmigemo')

" Perl言語用の正規表現での検索用プラグイン。
"call minpac#add('othree/eregex.vim', {'type': 'opt'})
"	使いこなせないため、導入見送り。

" ファイル検索
"call minpac#add('junegunn/fzf')
"	外部バイナリからの実行補佐プラグイン？

" Explorer
"call minpac#add('weirongxu/coc-explorer')
"nmap <Leader>er :call CocAction('runCommand', 'explorer.doAction', 'closest', ['reveal:0'], [['relative', 0, 'file']])<CR>
"	制約が多く使えない。
"		https://github.com/neoclide/coc.nvim
"		を使用している前提が必要？

" エクスプローラ
"call minpac#add('lambdalisue/fern.vim')
if isdirectory(expand(minpackSTART . "fern.vim"))  || isdirectory(expand(minpackOPT . "fern.vim"))
noremap <Leader>er :Fern . -reveal=%<CR>
nnoremap <F13> :<c-u>Fern . -drawer -stay -keep -toggle -reveal=%<CR>
"	j	ツリーを下に移動
"	k	ツリーを上に移動
"	l	フォルダを開く
"	h	フォルダを閉じる
"	Enter	(フォルダ上で)子階層に移動
"	Ctrl + w → Ctrl + w	内部ウィンドウの移動
"	Ctrl + h	親階層に移動
"	Ctrl + m	フォルダを開く。
"	e	ファイルを開く
"	Shift + e	垂直分割してファイルを開く。
"	-	ファイルを選択
"	Shift + c	ファイルをコピー
"
" 以下、無効化したいができない。
noremap <Nop>clipboardCopy <Plug>(fern-action-clipboard-copy)
noremap <Nop>clipboardMove <Plug>(fern-action-clipboard-move)
noremap <Nop>clipboardPaste <Plug>(fern-action-clipboard-paste)
noremap <Nop>trash <Plug>(fern-action-trash)
noremap <Nop>newDir <Plug>(fern-action-new-dir)
noremap <Nop>newFile <Plug>(fern-action-new-file)
endif

" エクスプローラ(上記より見やすい。)
call minpac#add('scrooloose/nerdtree', {'type': 'opt'})

" 以下、日本語用フォント
"call minpac#add('tsunesan3/awsome-jp-coding-fonts', {'type': 'opt'})
"	プラグイン導入ではなく、直接zip形式で取得し、好みのフォントを手動でインストールするのが吉(すべてを取得するのは容量が大きく、時間がかかる)。


" タグ登録済みの一覧表示
call minpac#add('preservim/tagbar', {'type': 'opt'})
"call minpac#add('majutsushi/tagbar', {'type': 'opt'})


" コンパイル実行
call minpac#add('thinca/vim-quickrun', {'type': 'opt'})

" Git
call minpac#add('airblade/vim-gitgutter')
"	※他のプラグインより優先度が高いようだ(lspの指摘を差し置いて、差分表示が優先された)。

call minpac#add('tpope/vim-fugitive')
call minpac#add('tpope/vim-rhubarb', {'type': 'opt'})	" vim-fugitiveとの連携で、ブラウザでの比較を行う。
	" :Gbrowse		github.com 上の該当のファイルをブラウザで開いてくれてプレビュー

" マーク表示
call minpac#add('jacquesbh/vim-showmarks', {'type': 'opt'})

" 囲み文字の編集
"call minpac#add('jiangmiao/auto-pairs')	" 括弧入力により、閉じ括弧を自動入力する(削除も対応)。
"call minpac#add('Raimondi/delimitMate', {'type': 'opt'})
"call minpac#add('cohama/lexima.vim', {'type': 'opt'})

call minpac#add('kana/vim-smartinput', {'type': 'opt'})

"call minpac#add('vim-denops/denops.vim')
"call minpac#add('higashi000/dps-kakkonan')
"	使い方が分からない。

"call minpac#add('rhysd/vim-operator-surround')

" やり直し・取り消しを取り消す。
"call minpac#add('sjl/gundo.vim')
"	※Pythonで動けるコンパイル済みのvimエディタが必須。


" やり直し・取り消しを取り消す。
call minpac#add('mbbill/undotree', {'type': 'opt'})

" セッション管理
call minpac#add('xolox/vim-session', {'type': 'opt'})
call minpac#add('xolox/vim-misc', {'type': 'opt'})

" プロジェクト管理
call minpac#add('mattn/vim-findroot', {'type': 'opt'})

" タブ補完
"call minpac#add('ervandew/supertab')
"	普通のTabキー入力が打てなくなる(Ctrl+TabでTab入力)。
"	⇒なるほど・・・文字に続けてTabを打つ場合に補完が働くのか・・・やっぱり邪魔くさいな。

" カレンダ表示
call minpac#add('itchyny/calendar.vim')
"	これはさすがにやり過ぎ。と言うか、使い勝手は悪い。

"	文字コードの自動判定(以下、どちらもutf7やutf16は判定してくれない)
"call minpac#add('mbbill/fencview')
"call minpac#add('tyru/fencview.vim')

endif	" パッケージ管理の読み込みなど
"	ーーーーーーーーーーーーーーーーーー 遅延読み込みここまで ーーーーーーーーーーーーーーーーーー

let g:session_menu = 0
"packadd previm


"if isdirectory(expand(minpackSTART . "open-browser.vim"))  || isdirectory(expand(minpackOPT . "open-browser.vim"))
"	packadd open-browser.vim
"endif
"if isdirectory(expand(minpackSTART . "vim-goimports"))  || isdirectory(expand(minpackOPT . "vim-goimports"))
"	packadd vim-goimports
"endif
"if isdirectory(expand(minpackSTART . "vim-lsp-snippets"))  || isdirectory(expand(minpackOPT . "vim-lsp-snippets"))
"	packadd vim-lsp-snippets
"endif
"if isdirectory(expand(minpackSTART . "vim-quickrun"))  || isdirectory(expand(minpackOPT . "vim-quickrun"))
"	packadd vim-quickrun
"endif
"if isdirectory(expand(minpackSTART . "tagbar"))  || isdirectory(expand(minpackOPT . "tagbar"))
"	packadd tagbar
"endif
"if isdirectory(expand(minpackSTART . "gundo.vim"))  || isdirectory(expand(minpackOPT . "gundo.vim"))
"	packadd gundo.vim
"endif
"if isdirectory(expand(minpackSTART . "undotree"))  || isdirectory(expand(minpackOPT . "undotree"))
"	packadd undotree
"	if has("persistent_undo")
"		set undodir = s:backup_dir . "/.undodir"
"		set undofile
"	endif
"endif
"if isdirectory(expand(minpackSTART . "vim-showmarks"))  || isdirectory(expand(minpackOPT . "vim-showmarks"))
"	packadd vim-showmarks
"endif
"if isdirectory(expand(minpackSTART . "xolox/vim-session"))  || isdirectory(expand(minpackOPT . "xolox/vim-session"))
"	packadd xolox/vim-session
"endif
"if isdirectory(expand(minpackSTART . "xolox/vim-misc"))  || isdirectory(expand(minpackOPT . "xolox/vim-misc"))
"	packadd xolox/vim-misc
"endif
"if isdirectory(expand(minpackSTART . "mattn/vim-findroot"))  || isdirectory(expand(minpackOPT . "mattn/vim-findroot"))
"	packadd mattn/vim-findroot
"endif
"if isdirectory(expand(minpackSTART . "tsunesan3/awsome-jp-coding-fonts"))  || isdirectory(expand(minpackOPT . "tsunesan3/awsome-jp-coding-fonts"))
"	packadd tsunesan3/awsome-jp-coding-fonts
"	set guifont=Sarasa:h14
	"	例えば、CicaV3をVimで使いたいのであれば、
	"	CicaV3ディレクトリ配下にあるCica.ttcを右クリックし、インストールを選ぶ。
"endif
"packadd syntastic
"	packadd minpac


" 以下、遅延読み込み用の対応(これをすることで遅延読み込みにしたのが無駄になる？)。
"	読み込む順番が大事なプラグインがあるため、気をつけて配置すること。
let packPluginlists = [
	\ 'vim-misc',
	\ 'vim-session',
	\ 'vim-goimports',
	\ 'vim-lsp-snippets',
	\ 'vim-quickrun',
	\ 'tagbar',
	\ 'gundo.vim',
	\ 'undotree',
	\ 'vim-findroot',
	\ 'nerdtree',
	\ 'vim-showmarks',
	\ 'vim-rhubarb',
	\ 'vim-commentary',
	\ 'delimitMate',
	\ 'lexima.vim',
	\ 'vim-smartinput',
	\ ]
for pluginPack in packPluginlists
	if isdirectory(expand(minpackSTART . pluginPack))  || isdirectory(expand(minpackOPT . pluginPack))
		exe("packadd " . pluginPack)
	endif
endfor

" ここまでがIDE用の設定プラグイン

" すべてのプラグインを起動時に読み込むのであれば、以下を実行。
"	基本的に、vimrc読み込み後に、自動的に下記コマンドが実行される。
"packloadall

" ■マーク
if isdirectory(expand(minpackSTART . "vim-showmarks"))  || isdirectory(expand(minpackOPT . "vim-showmarks"))
":DoShowMarks!
" 起動時にマーク表示
aug show-marks-sync
	au!
	au BufReadPost * sil! DoShowMarks
aug END
endif

if isdirectory(expand(minpackSTART . "vim-indent-guides"))  || isdirectory(expand(minpackOPT . "vim-indent-guides"))
	" デフォルトマッピング：<Leader>ig.	トグル
" 以下、常に有効化。
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_exclude_filetypes = ['help', 'nerdtree', 'tagbar' ]
" 以下、gVim用の色変更(逆に言えば、これを設定しなければ動かない？)。
"let g:indent_guides_auto_colors = 0
"autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=3
"autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=4
endif

if isdirectory(expand(minpackSTART . "indentLine"))  || isdirectory(expand(minpackOPT . "indentLine"))
	" Tabでは動かない？
	" シンタックスハイライトが効かないファイルタイプがあるようだ。
	"	https://qiita.com/Layzie/items/a1c8d14bccb14c02eb1b
let g:indentLine_color_term =239
let g:indentLine_color_gui = '#708090'
let g:indentLine_char = '¦'
"let g:indentLine_char = '' "use ¦, ┆ or │ 
"let g:indentLine_char_list = ['|', '¦', '┆', '┊']
endif

" ■IDEのように補完してくれる
if isdirectory(expand(minpackSTART . "vim-lsp"))  || isdirectory(expand(minpackOPT . "vim-lsp"))
" ファイルの変更に伴いリアルタイムにエラー表示する機能 
let g:lsp_diagnostics_enabled = 1
let g:lsp_diagnostics_echo_cursor = 1

" LSP の仕様である textEdit を有効にする設定
let g:lsp_text_edit_enabled = 0

let g:lsp_preview_float = 1
let g:lsp_diagnostics_float_cursor = 1
let g:lsp_settings_filetype_go = ['gopls', 'golangci-lint-langserver']

let g:lsp_signs_enabled = 0
let g:lsp_diagnostics_echo_cursor = 0

let g:lsp_settings = {}
let g:lsp_settings['gopls'] = {
  \  'workspace_config': {
  \    'usePlaceholders': v:true,
  \    'analyses': {
  \      'fillstruct': v:true,
  \    },
  \  },
  \  'initialization_options': {
  \    'usePlaceholders': v:true,
  \    'analyses': {
  \      'fillstruct': v:true,
  \    },
  \  },
  \}
endif


" Goインポートプラグイン
if isdirectory(expand(minpackSTART . "vim-goimports"))  || isdirectory(expand(minpackOPT . "vim-goimports"))
"let g:goimports = 1
"let g:goimports_simplify = 1
unlet! g:goimports_simplify
endif


if isdirectory(expand(minpackSTART . "asyncomplete.vim"))  || isdirectory(expand(minpackOPT . "asyncomplete.vim"))
let g:asyncomplete_smart_completion = 1
let g:asyncomplete_remove_duplicates = 1

" 自動で入力補完ポップアップを表示する設定
let g:asyncomplete_auto_popup = 1
let g:asyncomplete_auto_completeopt = 1
" ポップアップを表示するまでのディレイ
let g:asyncomplete_popup_delay = 200
endif


" For snippets
if isdirectory(expand(minpackSTART . "ultisnips"))  || isdirectory(expand(minpackOPT . "ultisnips"))
"	funcと入力してタブを押下するとスニペットが展開されるようだが、動かないぞ？
let g:UltiSnipsExpandTrigger="<Tab>"
let g:UltiSnipsJumpForwardTrigger="<Tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-Tab>"
let g:UltiSnipsEditSplit="vertical"

" 自作スニペット
let g:UltiSnipsSnippetsDir = '~/.vim/snippets'
set runtimepath+=~/.vim/snippets
" そもそもスニペットって何？
endif

" 以下、使いこなせないスニペット用プラグイン設定。
if isdirectory(expand(minpackSTART . "vim-vsnip"))  || isdirectory(expand(minpackOPT . "vim-vsnip"))
" 保存場所。
let g:vsnip_snippet_dir = s:backup_dir

" Expand
imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'

" Expand or jump
imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'

" Jump forward or backward
imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'

" Select or cut text to use as $TM_SELECTED_TEXT in the next snippet.
" See https://github.com/hrsh7th/vim-vsnip/pull/50
nmap s  <Plug>(vsnip-select-text)
xmap s  <Plug>(vsnip-select-text)
nmap S  <Plug>(vsnip-cut-text)
xmap S  <Plug>(vsnip-cut-text)

" If you want to use snippet for multiple filetypes, you can `g:vsnip_filetypes` for it.
let g:vsnip_filetypes = {}
let g:vsnip_filetypes.javascriptreact = ['javascript']
let g:vsnip_filetypes.typescriptreact = ['typescript']
endif

" 以下、Pythonを別途導入する必要があるスニペット用プラグイン。
if isdirectory(expand(minpackSTART . "deoppet.nvim"))  || isdirectory(expand(minpackOPT . "deoppet.nvim"))
	call deoppet#initialize()
	call deoppet#custom#option('snippets',
	\ map(globpath(&runtimepath, 'neosnippets', 1, 1),
	\     "{ 'path': v:val }"))

	imap <C-k>  <Plug>(deoppet_expand)
	imap <C-f>  <Plug>(deoppet_jump_forward)
	imap <C-b>  <Plug>(deoppet_jump_backward)
	smap <C-f>  <Plug>(deoppet_jump_forward)
	smap <C-b>  <Plug>(deoppet_jump_backward)
endif

if isdirectory(expand(minpackSTART . "vim-lsp-neosnippet"))  || isdirectory(expand(minpackOPT . "vim-lsp-neosnippet"))
imap <expr> <Tab> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<Tab>"
smap <expr> <Tab> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<Tab>"
endif

" ■シンタックスチェック
if isdirectory(expand(minpackSTART . "syntastic"))  || isdirectory(expand(minpackOPT . "syntastic"))
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
endif

if isdirectory(expand(minpackSTART . "nerdtree"))  || isdirectory(expand(minpackOPT . "nerdtree"))
nnoremap <Leader>er :NERDTreeToggle<CR>
	" ●ファイル操作系
"		o(enter)	ファイルを開く
"		go	ファイルを開き、カーソルはツリーに保持する
"		t	タブで開く
"		T	タブで開き、移動はしない
"		i	水平分割して開く
"		gi	水平分割して開き、移動はしない
"		s	垂直分割して開く
"		gs	垂直分割して開き、移動はしない
"
	" ●ディレクトリ操作系
"		o(enter)	フォルダを開く
"		O	再帰的にディレクトリをすべて開く
"		x	親ディレクトリを閉じる
"		X	再帰的にすべての子ディレクトリを閉じる
"		e	新しいツリーを生成する
"
	" ●ツリー操作系
"		P	ルートディレクトリへ移動
"		p	親ディレクトリへ移動
"		K	一番上へ移動
"		J	一番下へ移動
"		Ctrl+k	一つ上へ移動
"		Ctrl+j	一つ下へ移動
"
	" ●ファイルシステム系
"		C	ツリーのルートを選択したディレクトリに変更
"		u	ツリーのルートを上の階層にする
"		U	変更前のツリーの状態を保持して、ツリーのルートを上の階層にする
"		r	選択したディレクトリをリフレッシュする
"		R	ツリーのルートをリフレッシュする
"		m	メニューを表示する
"		cd	選択したディレクトリにcwdを変更する
"		CD	cwdをツリールートに変更する
"
	" ●その他
"		I	隠しファイルの表示、非表示
"		B	ブックマークの表示・非表示
"		F	ファイルの表示・非表示
endif

" ■Git
"	ステータスに、現在のバッファから変更・追加・削除の行数を表示する。
if isdirectory(expand(minpackSTART . "vim-gitgutter"))  || isdirectory(expand(minpackOPT . "vim-gitgutter"))
function! GitStatus()
	let [a,m,r] = GitGutterGetHunkSummary()
	return printf('+%d ~%d -%d', a, m, r)
endfunction
set statusline+=%{'(Git:'.GitStatus().')'}

"	以下、記号列を常時表示。
set signcolumn=yes
"	以下、起動時のハイライト有効設定
let g:gitgutter_highlight_lines = 1
"let g:gitgutter_highlight_linenrs = 1
"if ( has('win32') || has('win64') )
"		※以下を有効にすることで、GitGutterが無効化される？
"	let g:gitgutter_git_executable = 'C:\Program Files\Git\bin\git.exe'
"endif

let g:gitgutter_sign_allow_clobber = 0	" 優先度を上げる。
"let g:gitgutter_set_sign_backgrounds = 1
let g:gitgutter_sign_removed_first_line = "^_"
let g:gitgutter_override_sign_column_highlight = 0

"	色の変更は、GUIでは反映されない？
"	以下、記号列の色がなくなる？(下記とかぶるため、順序に気をつけること)
"highlight! link SignColumn LineNr

"	以下、記号列の色をつける(上記とかぶるため、順序に気をつけること)。
highlight SignColumn guibg=NONE ctermbg=NONE

"	以下、記号列の記号色が変わる。
highlight GitGutterAdd ctermfg=blue ctermbg=NONE
highlight GitGutterChange ctermfg=yellow "ctermbg=NONE
highlight GitGutterDelete ctermfg=red "ctermbg=NONE
highlight GitGutterChangeDelete ctermfg=green "ctermbg=NONE

"	以下、文書上の線の色が変わる(予想に反した色になる)。
"	highlight GitGutterAddLine ctermfg=NONE ctermbg=blue	" 追加
"	highlight GitGutterChangeLine ctermfg=yellow ctermbg=NONE	" 変更
"	highlight GitGutterDeleteLine ctermfg=white ctermbg=red	" 削除
"	highlight GitGutterChangeDeleteLine ctermfg=green ctermbg=green	" 既存の部分を削除で反映？

" ■Git操作用プラグインの簡易操作
" vim-GitGutter
noremap <leader>ha :GitGutterStageHunk<cr>

" GitGutterの行ハイライト切り替え(トグル)
nmap <Leader>h :GitGutterLineHighlightsToggle<CR>
"	CUI用vimの場合、F16以降はMacに機能が奪われてしまい、一般的なファンクションキーとして動かない。
endif


" vim-fugitive
if isdirectory(expand(minpackSTART . "vim-fugitive"))  || isdirectory(expand(minpackOPT . "vim-fugitive"))
nnoremap <leader>gs :tab sp<CR>:Gstatus<CR>:only<CR>
"	ステータス。
nnoremap <leader>ga :Gwrite<CR>
"	git add
nnoremap <leader>gb :Gblame<CR>
"	git blame
	" 行ごとに最終コミットされた時期・誰かを一覧にする。
"alias logall='log --graph --pretty=format:\'%Cred%h %Cgreen(%>(15,trunc)%cr, %ci) %C(bold blue)<%an>%Creset -%C(yellow)%d%Creset %s\' --abbrev-commit --date=relative --all'
nnoremap <leader>gc :Gcommit<CR>
"	git commit
nnoremap <leader>gl :Git log<CR>
"	git log
nnoremap <leader>gh :tab sp<CR>:0Glog<CR>
"	変更履歴(架空コマンドgit history)
" abbrev for `git history`: create new quickfix tab for history
nnoremap <leader>gp :Gpush<CR>
"	git push
nnoremap <Leader>gll :Gpull<CR>
"	git pull
nnoremap <leader>gf :Gfetch<CR>
"	git fetch
nnoremap <leader>gd :Gvdiff<CR>
"	diff	<Leader>gsのdvと同じ
nnoremap <leader>gr :Grebase -i<CR>
"	git rebase -i
nnoremap <leader>gg :Ggrep 
"	gitgrep
nnoremap <leader>gm :Gmerge 
"	git merge
nnoremap <Leader>o :Gbrowse<CR>
endif


" タグ一覧表示の切り替え(トグル)
if isdirectory(expand(minpackSTART . "tagbar"))  || isdirectory(expand(minpackOPT . "tagbar"))
nmap <F8> :TagbarToggle<CR>
endif

" アンドゥツリー切り替え(トグル)
if isdirectory(expand(minpackSTART . "gundo.vim"))  || isdirectory(expand(minpackOPT . "gundo.vim"))
nmap <Leader>u :GundoToggle<CR>
endif

" アンドゥツリー切り替え(トグル)
if isdirectory(expand(minpackSTART . "undotree"))  || isdirectory(expand(minpackOPT . "undotree"))
nmap <Leader>u :UndotreeToggle<CR>
endif

" プロジェクト管理
if isdirectory(expand(minpackSTART . "vim-findroot"))  || isdirectory(expand(minpackOPT . "vim-findroot"))
"	以下、ルートディレクトリ設定
let g:findroot_patterns = [
\  'tags',
\  'README.md',
\  '.gitignore',
\  'Rakefile',
\  'pom.xml',
\  'project.clj',
\  '*.csproj',
\  '*.sln',
\  '.git/',
\  '.svn/',
\  '.hg/',
\  '.bzr/',
\]

" カレントディレクトリの変更不可。
let g:findroot_not_for_subdir = 0
endif


" セッション管理
if isdirectory(expand(minpackSTART . "vim-session"))  || isdirectory(expand(minpackOPT . "vim-session"))
if ( has('win32') || has('win64') )
	let g:session_directory = expand($HOME) . "/.vim_backup/sessions"
else
	let g:session_directory = expand('~/.vim_backup/sessions')
endif
let g:session_lock_directory = g:session_directory
let g:session_extension = '.vimSession'
let g:session_autosave = 'yes'
let g:session_autoload = 'no'
let g:session_autosave_periodic = 0
let g:session_autosave_silent = 1
" let g:session_verbose_messages = 0
" let g:loaded_session = 1	" 使う時は0


" ■使い方
"	:SaveSession　⇒　~/.vim_backup/sessions/default.vimSession
"	:SaveSession hoge　⇒　~/.vim_backup/sessions/hoge.vimSession
"	:OpenSession　⇒　~/.vim_backup/sessions/default.vimSession
"	:OpenSession hoge　⇒　~/.vim_backup/sessions/hoge.vimSession
"	:ViewSession　⇒　保存済みのセッションが一覧として表示される(表示される番号のセッションを開いた場合、セッションファイルそのものが開く)。
"	:DeleteSession　⇒　保存済みのセッションが一覧として表示され、番号を入力することで、それに紐付くセッションファイルが削除される。
"	:CloseSession　⇒　現在開いているセッションが終了する(バッファにも残らない)。
"	:OpenTabSession　⇒　現在のバッファを開きつつ指定のセッションを開く。
"	:SaveTabSession
"	:AppendTabSession
"	:CloseTabSession
endif

if isdirectory(expand(minpackSTART . "vim-fugitive"))  || isdirectory(expand(minpackOPT . "vim-fugitive"))
function! s:save_session(...)
	if a:0
		let session_name = a:1
	else
		let session_name = fugitive#head()
	end

	if strlen(session_name)
		execute 'SaveSession .'.session_name.'.session'
	else
			SaveSession
	endif
endfunction

function! s:load_session(...)
	if a:0
		let session_name = a:1
	else
		let session_name = fugitive#head()
	end

	if strlen(session_name)
		execute 'OpenSession .'.session_name.'.session'
	else
		execute 'OpenSession '.g:session_default_name
	endif
endfunction

command! -nargs=? BranchSave call s:save_session(<f-args>)
command! -nargs=? BranchLoad call s:load_session(<f-args>)
endif


" supertab
"let g:SuperTabDefaultCompletionType = "<c-n>"
"	補完の操作を逆にする。

"	ーーーここまでがパッケージ設定ーーー

if (has('win32') || has('win64') )
	let g:previm_open_cmd = 'C:\/\/Program\ Files\/Mozilla\ Firefox\/firefox.exe'	" open-browser.vim
elseif (has('gui_macvim') || has('mac') )
	"let g:previm_open_cmd = 'open -a Safari'	" open-browser.vim
	let g:previm_open_cmd = 'open -a Firefox'	" Safari動かなかったため。
elseif has('xfontset')
endif

autocmd BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set filetype=markdown
let g:vim_markdown_folding_disabled=1	" 自動折りたたみ無効化
" Ctrl-pでプレビュー(他のプラグインとダブってしまうため、\pにした)
"	CtrlPプラグインとかぶるため変更	nnoremap <silent> <C-p> :PrevimOpen<CR>
augroup filetype_markdown
	" マークダウンファイルのみ有効
	au!
	au FileType markdown packadd previm
	au FileType markdown nnoremap <Leader>p :PrevimOpen<CR>
augroup END


command! PackUpdate source ~/.vimrc | call minpac#update()
command! PackClean  source ~/.vimrc | call minpac#clean()
"command! PackStatus packadd minpac | call minpac#status()
command! PackStatus source ~/.vimrc | call minpac#status()
"	ーーーパッケージ管理下での設定ここまでーーー

"	エディタ起動後に、デスクトップに移動する。
"cd $HOME/Desktop
"set autochdir
"	これをコメントアウトする場合、上記のデスクトップ移動もコメントアウトする必要がある。

" バッファで開いているファイルのディレクトリでエクスクローラを開始する
"set browsedir=buffer

" Vimから使えるデバッガUI
augroup MyTermDebug
	" C言語ファイルのみ有効
	au!
	au FileType c packadd termdebug
augroup END


" MacOS Xメニューの日本語化 (メニュー表示前に行なう必要がある)
if has('mac')
	set langmenu=japanese
endif


" メッセージを日本語にする (Windowsでは自動的に判断・設定されている)
if !(has('win32') || has('mac')) && has('multi_lang')
	if !exists('$LANG') || $LANG.'X' ==# 'X'
		if !exists('$LC_CTYPE') || $LC_CTYPE.'X' ==# 'X'
			language ctype ja_JP.eucJP
		endif
		if !exists('$LC_MESSAGES') || $LC_MESSAGES.'X' ==# 'X'
			language messages ja_JP.eucJP
		endif
	endif
endif


"---------------------------------------------------------------------------
" フォント設定:
"

" □や○の文字があってもカーソル位置がずれないよう。
" □とか○の文字があってもカーソル位置がずれないようにする
if exists('&ambiwidth')
	" 一部のUCS文字の幅を自動計測して決める
	set ambiwidth=double
endif

"	シンタックスハイライト有効化
syntax reset
syntax on


"---------------------------------------------------------------------------

" 上書き後に終了するコマンドを無効化する。
nnoremap ZZ <Nop>

"---------------------------------------------------------------------------
" 日本語入力に関する設定:
"
"	インサートモードでバックスペース機能を有効にする。
	"BSで削除できるものを指定する
	" indent  : 行頭の空白
	" eol     : 改行
	" start   : 挿入モード開始位置より手前の文字
set backspace=indent,eol,start

" 大小文字を区別せずに検索する。
set ignorecase
"	一時的に区別しせずに検索する場合は、\cを付けることで、対応できる。
"		\C	大文字にした場合、区別して検索する(このオプションは、ignorecase・smartcaseより優先される)。

" 大文字を含む場合は、大小文字を区別して検索するが、すべて小文字の場合は大小文字を区別せずに検索する。
set smartcase

"	検索方法を自然な正規表現に変換(very Magic)
nnoremap / /\v

"	マッチ箇所をハイライト
set hlsearch
"		ハイライト解除の場合はExコマンド上で"noh"を打てば消える(再度検索すればハイライトになる)。
nnoremap <C-l> :nohlsearch<CR><C-l>
"		Ctrl+l	の組み合わせでハイライト解除にした。

"	ファイル端に達した場合、一周して検索を続行する。
set wrapscan

" QuickFixおよびHelpでは q でバッファを閉じる
autocmd FileType help,qf nnoremap <buffer> q <C-w>c

"	以下、vimgrep・grep・Ggrepの3種類のコマンドに対して、自動的にquickfix-windowを開く。
autocmd QuickFixCmdPost *grep* cwindow

"	対となるキーワード間の移動(検索)
if &compatible
	set nocompatible
endif
filetype plugin on
"runtime macros/matchit.vim

" 対の記号移動。
"let g:matchit = 0
"source $VIMRUNTIME/macros/matchit.vim

" 括弧の対応関係を一瞬表示
"set showmatch
"	%移動の拡張
source $VIMRUNTIME/macros/matchit.vim

" 検索後にジャンプした際に検索単語を画面中央に持ってくる
"nnoremap n nzz
"nnoremap N Nzz
"nnoremap * *zz
"nnoremap # #zz
"nnoremap g* g*zz
"nnoremap g# g#zz

" ctagsの検索場所を親ディレクトリから再帰的に探す。
"		https://qiita.com/aratana_tamutomo/items/59fb4c377863a385e032
"		https://github.com/universal-ctags/ctags
set tags=tags;$HOME;
"	Ctrl+]：定義場所に移動する。Push
"	Ctrl+t：タグスタックを遡る(カーソルが前いたファイルの位置に戻る)。Pop
"	:tn・:tp：同名タグを順に移動する。
"	ctags -R .	タグ作成(-Rオプション：現在のディレクトリから再帰的に解析する。-fオプション：タグ名を付けられる。)
"	以下、自動でタグ作成(ファイルを保存するたびに、そのディレクトリにタグファイルが生成される)
"augroup ctags
"	autocmd!
"	autocmd BufWritePost *.go,*.py,*.c,*.h silent! !ctags -R &
"augroup END
"	以下、タグファイルがなければ何もしない。
function! s:execute_ctags() abort
	" 探すタグファイル名
	let tag_name = 'tags'

	" ディレクトリを遡り、タグファイルを探し、パス取得
	let tags_path = findfile(tag_name, '.;')

	" タグファイルパスが見つからなかった場合
	if tags_path ==# ''
		return
	endif

	" タグファイルのディレクトリパスを取得
	" `:p:h`の部分は、:h filename-modifiersで確認
	let tags_dirpath = fnamemodify(tags_path, ':p:h')
	" 見つかったタグファイルのディレクトリに移動して、ctagsをバックグラウンド実行（エラー出力破棄）
	execute 'silent !cd' tags_dirpath '&& ctags -R -f' tag_name '2> /dev/null &'
endfunction
autocmd BufWritePost * call s:execute_ctags()
command! TagsMake !ctags -R .

" 改行時に、前の行を構文解析後に、カレント行のインデント増減を決める。
set smartindent

" <C-a>の増減を10進数で行う。
set nrformats=


" コマンド補完
set wildmenu
"set wildmode=list:longest,full
set wildmode=longest,full
"set history=800 " 保存するコマンド履歴の数

" 補完表示時のEnterで決定)
inoremap <expr><CR>  pumvisible() ? "<C-y>" : "<CR>"

"	Tabで確定したい。
inoremap <expr><Tab> pumvisible() ? "<C-y>" : "\<Tab>"
inoremap <expr><CR>  pumvisible() ? "<C-y>" : "\<CR>"
"	補完候補の選択を矢印キーで行う。
inoremap <expr><C-n> pumvisible() ? "<Down>" : "<C-n>"
inoremap <expr><C-p> pumvisible() ? "<Up>" : "<C-p>"
" 常時補完候補を表示する(初回の補完時に挿入しない)
"set completeopt=menuone,noinsert
set completeopt=menuone

"	インサート補完モード
"		Ctrl+x
"		このコマンドに続けて、以下の4種類のどれかを選ぶことで、補完が完了する。
"			Ctrl+l	行をまるごと補完
"			Ctrl+]	タグ補完
"			Ctrl+f	ファイル名補完
"			s		スペルチェック候補の補完(spell設定が有効の場合)
"		help ins-completion
"		help 'complete'

"	スペルチェックをするようだが、日本語未対応なのか、技術用語未対応なのか分からないが、使い物にならない。
"set spell

"	ファイル名の指定だけでPathを指定せずに開けるようにする。
"if ( has('win32') || has('win64') )
"	set path+="C:\asakunotomohiro\dotfiles\**"
"endif


"		個人の辞書ファイルから補完候補を抜き出す。
"set complete+=k~/dotfiles/mydic.txt

"---------------------------------------------------------------------------
" KaoriYaでバンドルしているプラグインのための設定
" autofmt: 日本語文章のフォーマット(折り返し)プラグイン。
set formatexpr=autofmt#japanese#formatexpr()


"---------------------------------------------------------------------------
" GUI固有ではない画面表示の設定:

" ビープ音を鳴らさない
"set vb t_vb=
set belloff=all

" 他で書き換えられたら自動で読み直す
set autoread

" 行番号を表示 (nonumber:表示しない)
set number

"	下記は、行番号をカレント行から相対的に表示
"set relativenumber
"		状況によっては動作が遅くなる。
set norelativenumber

" ルーラーを表示 (noruler:非表示)
"	右下に表示される。
set ruler

" タブや改行を表示 (nolist:表示しない)
set list

" どの文字でタブや改行を表示するかを設定
set listchars=tab:>-,extends:<,trail:-,eol:<

" カーソルを行頭、行末で止まらないようにする
"set whichwrap=b,s,h,l,<,>,[,]

" 常にステータス行を表示 (詳細は:he laststatus)
"	EXコマンドラインとの境目を付けるために必要だろう。
set laststatus=2
"	Androidの場合少ない幅にしたいが、1を設定した場合表示されなくなる。

" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
"	EXコマンドラインのため、2ぐらいが適当？（1との違いが不明）。
set cmdheight=2

" タイプ中のコマンドを表示
set showcmd


" カーソルの移動として画面幅いっぱいまで移動させる設定。

set scrolloff=0
"	:help L

" 見た目の行数で移動する.
:nnoremap j gj
:nnoremap k gk

"---------------------------------------------------------------------------
" 編集に関する設定:

" タブの画面上での幅
set tabstop=4

" 改行時に、前の行のインデントを継続する。
"set autoindent

" 自動改行不可(日本語には関係なく改行するようだ？)
set textwidth=0
set formatoptions=q
"set formatoptions=r
" シフト量の幅（"<<" または ">>"）
"	smartindentで増減する幅
set shiftwidth=4
set softtabstop=4
"set expandtab


" 挿入モードの時にプットする場合、自動インデント機能を無効にする。
set pastetoggle=<F2>
inoremap <C-g><C-v> <F2><C-r>"<F2>
"		Ctrl+g→Ctrl+v	→　いわゆるコピペのGvim版
"		挿入モードの時に、<C-r>"<Esc>で改行付きの複数行が貼り付けられる。
"		F2キー押下で設定を有効・無効に切り替える必要がある。


"---------------------------------------------------------------------------
" バックアップファイル・スワップファイル
set backup
set undofile

"set noundofile
if ( has('win32') || has('win64') )
"	let s:backup_dir = 'C:/vim_backup'
	let s:backup_dir = expand($HOME) . "/.vim_backup"
	let s:undo_dir = expand($HOME) . "/.vim_backup/undofile"
	"	本来これらは%TEMP%ディレクトリが望ましいだろう。
else
	let s:backup_dir = expand('~/.vim_backup')
	let s:undo_dir = expand('~/.vim_backup/undofile')
endif
if !isdirectory(s:backup_dir) || !isdirectory(s:undo_dir)
	" どちらかがなければ以下の処理が走る。そのため、どちらか一方だけ存在した場合、それをコメントアウトしておくこと。
	exec mkdir(s:backup_dir, '', 0700)
	exec mkdir(s:undo_dir, '', 0700)
endif
let &backupdir = s:backup_dir
"let &directory = s:backup_dir	" スワップファイルの作成場所をカレントディレクトリにするため、コメントアウト。
" undofileが勝手に作られるが、無効化ではなく、作る場所を一カ所にまとめることにした。
	"	※これは、kaoriya版のVer.7.4.277からの仕様らしい。
let &undodir=&backupdir . "/undofile"	" アンドゥファイル
"set noundofile " アンドゥファイルを生成しない。
"set noswapfile "スワップファイルを生成しない。
"	以下、何？
set switchbuf=useopen

"	セッション管理用保存ディレクトリ。
"let s:sessionDir_dir = expand('~/.vim_backup/sessions')
"if !isdirectory(s:sessionDir_dir)
"	exec mkdir(s:sessionDir_dir, '', 0700)
"endif

" 最後のカーソル位置を復元する
if has("autocmd")
	autocmd BufReadPost *
	\ if line("'\"") > 0 && line ("'\"") <= line("$") | exe "normal! g'\"" |
	\ endif
endif

"---------------------------------------------------------------------------

"　日本語ヘルプが開くように設定する。
set helplang=ja,en

" .vimrcの編集中のみKキー押下することにより、Vimのマニュアルが開く。
augroup vimrc
	autocmd!
	autocmd FileType vim setlocal keywordprg=:help
augroup END


"---------------------------------------------------------------------------
" 文字コードの設定
"	ファイルの文字コードがlatin1の場合は、選別ミスのようだ。
set fileencodings=utf-8,iso-2022-jp,iso-2022-jp-1,iso-2022-jp-2,iso-2022-jp-3,ISO-2022-JP-2004,cp932,sjis,utf-7,euc-jp,ucs-bom,eucjp-ms,euc-jisx0213,utf-16,utf-16le
"	CUI版のvimでutf8ファイルを開く場合、下記では文字化けする。上記のUTF-8が前面に設定されている必要がある。
"set fileencodings=iso-2022-jp,iso-2022-jp-1,iso-2022-jp-2,iso-2022-jp-3,ISO-2022-JP-2004,cp932,sjis,utf-7,utf-8,euc-jp,ucs-bom,eucjp-ms,euc-jisx0213,utf-16,utf-16le
"	iso-2022-jp：日本語Jisのこと(しかし、適用されずにcp932で開かれる)。
"	utf-7は適用されず、utf-8で開かれる。
"	JIS・UTF7は開けず、文字化けする。
"	以下、読み込み直す。
"		:setl fenc=euc-jp
"
"	FencView.vimプラグインは、自動で文字コード判断可能なようだ。

" 改行コードの自動認識
"	改行コードを指定して開き直す場合
"		:e ++ff=mac
set fileformats=unix,dos,mac


" 日本語対応のための設定(Gvim初期起動時の設定にも関与する)
" ファイルを読込む時にトライする文字エンコードの順序を確定する。漢字コード自動判別機能を利用する場合には別途iconv.dllが必要。iconv.dllについてはREADME_w32j.txtを参照。ユーティリティスクリプトを読み込むことで設定される。
"source $VIMRUNTIME/encode_japan.vim
"set fileencoding=japan
set encoding=UTF-8
	" ※この設定が無効になっている(UTF8以外の)場合、エラーになるプラグイン(例えばGitGutter)が存在する。
	"	しかし、これ以外にも要因があるため、全く理解できないエラーのままなのは確か。

" 日本語整形スクリプト
let format_allow_over_tw = 1 " ぶら下り可能幅

"---------------------------------------------------------------------------
" マウスに関する設定:
"
" 解説:
" mousefocusは幾つか問題(一例:ウィンドウを分割しているラインにカーソルがあっている時の挙動)があるのでデフォルトでは設定しない。
" Windowsではmousehideが、マウスカーソルをVimのタイトルバーに置き日本語を入力するとチラチラするという問題を引き起す。
"

" どのモードでもマウスを使えるようにする
set mouse=a
" マウスの移動でフォーカスを自動的に切替えない (mousefocus:切替る)
set nomousefocus
" 入力時にマウスポインタを隠す (nomousehide:隠さない)
set mousehide
" ビジュアル選択(D&D他)を自動的にクリップボードへ (:help guioptions_a)
"set guioptions+=a


" ターミナルでマウスを使用。
set ttymouse=xterm2

"---------------------------------------------------------------------------
"	エクスプローラー
nnoremap <Leader>E :Explore<CR>
nnoremap <Leader>S :Sexplore<CR>	" ←通常:Seで水平分割上で開く.\Sで開くようになる.
nnoremap <Leader>V :Vexplore<CR>	" ←通常:Vexで水平分割上で開く.\Vで開くようになる.
"	新規タブページで開く場合は:Teを使う必要がある.

" 折りたたみ
set foldmethod=indent
"set foldmethod=manual
set foldcolumn=1	" 折りたたみの可視化
autocmd BufRead * normal zR
"	za：トグル
"	zo：折りたたみが開く
"	zc：折りたたむ
"	zR：すべての折りたたみを開く(上記の設定がこれにあたる)
"	zM：すべての折りたたみを閉じる。

"---------------------------------------------------------------------------
" MacVim-KaoriYa固有の設定

" migemo：ローマ字のまま日本語をインクリメンタル検索
let $PATH = simplify($VIM . '/../../MacOS') . ':' . $PATH
"set migemodict=$VIMRUNTIME/dict/migemo-dict
"set migemo
"	インクリメンタルサーチをしない.
"set noincsearch
set incsearch


" 印刷に関する設定:
set printmbfont=r:HiraMinProN-W3,b:HiraMinProN-W6
set printencoding=utf-8
set printmbcharset=UniJIS

let $LUA_DLL = simplify($VIM . '/../../Frameworks/libluajit-5.1.2.dylib')


if has('multi_byte_ime') || has('xim')
	" IME ON時のカーソルの色を設定
	highlight CursorIM guibg=Red guifg=LightRed
	" 挿入モード・検索モードでのデフォルトのIME状態設定
"	set iminsert=0 imsearch=0
endif

" カーソルハイライト
set cursorline " カーソルラインをハイライト

"		アンダーライン付き。
highlight CursorLine gui=underline guifg=NONE guibg=NONE

" 挿入モード時、ステータスラインの色を変更
" 参考URL：https://sites.google.com/site/fudist/Home/vim-nihongo-ban/vim-color#color-insertmode
"			https://qiita.com/jnchito/items/5141b3b01bced9f7f48f
let g:hi_insert = 'highlight StatusLine guifg=darkblue guibg=darkyellow gui=none ctermfg=blue ctermbg=yellow cterm=none'
if has('syntax')
	augroup InsertHook
	autocmd!
	autocmd InsertEnter * call s:StatusLine('Enter')
	autocmd InsertLeave * call s:StatusLine('Leave')
	augroup END
endif
let s:slhlcmd = ''
function! s:StatusLine(mode)
	if a:mode == 'Enter'
		silent! let s:slhlcmd = 'highlight ' . s:GetHighlight('StatusLine')
		silent exec g:hi_insert
	else
		highlight clear StatusLine
		silent exec s:slhlcmd
	endif
endfunction
function! s:GetHighlight(hi)
	redir => hl
	exec 'highlight '.a:hi
	redir END
	let hl = substitute(hl, '[\r\n]', '', 'g')
	let hl = substitute(hl, 'xxx', '', '')
	return hl
endfunction

"---------------------------------------------------------------------------

" タブ操作
"	以下、新規タブページを右端に作成する。
nnoremap <Leader>tn :$tabnew<CR>
nnoremap <Leader>tc :tabclose<CR>
"	以下、現在のバッファを新規タブで開く(現在のバッファは既存のタブに残る)
nnoremap <Leader>tm :tab split<CR>
"	以下、カレントタブページ以外を閉じる。
nnoremap <Leader>to :tabonly<CR>

" メモ
"	tabs：タブページと含まれているウィンドウ一覧を表示。
"	tabmove [N]：タブページ移動。


"---------------------------------------------------------------------------
nnoremap <Leader>ev :e ~\.vimrc<CR>
nnoremap <Leader>eg :e ~\.gvimrc<CR>

if ( has('win32') || has('win64') )
	" コピペはできないが、ヤンクなどをWindowsのクリップボードに保存する処理。
"	set clipboard=unnamed,autoselect

	"	全選択
	nnoremap <Leader>a ggVG


	nnoremap <Leader>eh :e ++enc=sjis $HOME/Documents/AutoHotkey.ahk<CR>
	"		いずれは、編集後に読み込み直すような設定をしたい。
	" ※ディレクトリ名に日本語などが含まれている場合、文字化けする。
	"		その場合は、"set encoding=UTF-8"にする必要がある。
endif

" ■コマンドの再マッピング
"	:map：再帰的なマッピングに用いられる(他のカスタムマッピングと相互作用する)。
"	:noremap：非再帰的なマッピングに用いられる(デフォルトのマッピングのみに作用する)。
"			　マッピング済みを調べる方法：:help index	←キーバイド一覧
"			　:mapコマンドでプラグインやユーザ定義のマッピング閲覧
"			　:map gは、gから始まるすべてのマッピングを表示する。
"	※:map：プラグインの提供するカスタムマッピングに対して使うようだ。
"	※:noremap：組み込みのマッピングに対して使う。
"
"	特殊キー
"		<space>	Spaceキー
"		<esc>	Escキー
"		<cr>・<enter>	Enterキー
"		<tab>	Tabキー
"		<bs>	Backspaceキー
"		<up>・<down>・<left>・<right>	矢印キー
"		<pageup>・<pagedown>	PageUpキー・PageDownキー
"		<f1>～<f12>	ファンクションキー
"		<home>・<insert>・<del>・<end>	Homeキー・Insertキー・Deleteキー・Endキー
"		<nop>	キーバインドとして何も動かない。
"			例）map <up> <nop>	上矢印キー無効
"	モード特化の再マッピング
"		:nmap・:nnoremap	ノーマルモード
"		:vmap・:vnoremap	ビジュアルモードとセレクトモード
"		:xmap・:xnoremap	ビジュアルモード
"		:smap・:snoremap	セレクトモード
"		:omap・:onoremap	オペレータ待ちモード
"		:map!・:noremap!	インサートモードとコマンドラインモード
"		:imap・:inoremap	インサートモード
"		:cmap・:cnoremap	コマンドラインモード
"		例）inoremap ' ''<esc>i	" 対応閉じ引用符を自動入力(自動入力後に、引用符に囲まれる状態で入力状態になる)
"
"augroup filetype_go
"	autocmd!
"	:autocmd FileType go inoremap ' ''<esc>i
"	:autocmd FileType go inoremap " ""<esc>i
"	:autocmd FileType go inoremap < <><esc>i
"	:autocmd FileType go inoremap ( ()<esc>i
"	:autocmd FileType go inoremap { {}<esc>i
"	:autocmd FileType go inoremap [ []<esc>i
"augroup end

"	■vim Script
" 変数定義で、レジスタaに文字列を持たせる場合、
"	let @a = 'hello world'
" 変数定義で、オプション(set変更)には&を付ける。
"	let &ignorecase = 0
" 文字列の連結
"	ドット演算子(.)を使う。
"	let g:hoge = g:bar . ' boo'
" 文字列は'で囲み、'記号を使う場合は、''にする。
"	注意：特定のコマンド直後にコメントとしてダブルクォーテーションを使えない場合がある(コメント行として認識してくれない)。
"
" ・条件文
"	if 条件
"		処理
"	elseif 条件
"		処理
"	endif
"	==	左右の文字列比較
"	==?	大小文字の区別せずに比較
"	==#	大小文字の区別して比較
"	=~	右辺の式にマッチしているかどうかを調べる(上記組み合わせ⇒=~?・=~#)。
"	!~	右辺の式にマッチしていないかどうかを調べる(上記組み合わせ⇒!~?・!~#)。
"	大小文字の区別は、ignorecaseの設定に依存する。
"
" ・リスト(Pythonに似ている。似ているだけで同じではない)
"	let animals = ['cat', 'dog', 'parrot']
"		0から数える。-1で最後の要素を取り出す。
"	スライス
"		let slice = animals[1:]	←['dog, 'parro']
"		追加
"			call add(animals, 'octopus')
"			let animals = add(animals, 'octopus')
"		2番目に要素を追加
"			call insert(animals, 'raven', 2)
"		2番目の要素を取り除く
"			unlet animals[2]
"			call remove(animals, 0)
"			let cat = remove(animals, 0)
"		連結
"			let birds = ['raven', 'parrot']
"			let hoge = animals + birds
"			call extend(animals, birds)
"		並び替え(昇順)
"			call sort(animals)
"		要素のインデックス
"			let i = index(animals, 'parrot')
"		空の確認
"			if empty(animals)
"				空
"			endif
"		長さ
"			len(animals)
"		要素数
"			count(animals, 'cat')
" ・辞書(Pythonに似ている。似ているだけで同じではない)
"	let animal_names = {
"		\ 'cat': 'Miss Cattington',
"		\ 'dog': 'Mr Dogson',
"		\ 'parrot': 'Polly'
"		\}
"	要素の取得
"		let cat_name = animal_names['cat']
"		let cat_name = animal_names.cat	←キーが数字・文字・アンダースコアから構成されている必要がある。
"	要素の追加
"		let animal_names['raven'] = 'Raven R. Raventon'
"	エントリの削除
"		unlet animal_names['raven']
"		let raven = remove(animal_names, 'raven')
"	マージ(重複した場合上書く)
"		call extend(animal_names, {'bobcat': 'Sir Meowtington'})
"	キーの確認
"		if has_key(animal_names, 'cat')
"			echo animal_names['cat']
"		endif
" ・ループ
"	リストと辞書の繰り返しは、for文を使う。
"		for animal in animals ←リストループ
"			echo animal
"		endfor
"		for animal in keys(animal_names) 辞書ループ
"			echo animal . animal_names[animal]
"		endfor
"		for [animal, name] in items(animal_names)
"			echo animal . name
"		endfor
"	途中制御
"		continue
"		break
"	while文
"		let animals = ['dog', 'cat', 'parrot']
"		while !empty(animals)
"			echo remove(animals, 0)
"		endwhile
" ・関数(先頭は大文字で始める)
"	複数回の読み込みはエラーになるため、感嘆符を付けることで回避できる。
"		function! AnimalGreeting(animal)
"			return a:animal
"		endfunction
"	関数の呼び出し
"		call AnimalGreeting('cat')
"	可変長引数の関数
"		function! AnimalGreeting(...)
"			echo a:1 . a:2
"		endfunction
"		call AnimalGreeting('cat', 'dog')
"		すべての引数リスト：a:000
"	組み合わせ
"		function! AnimalGreeting(animal, ...)
"			echo a:animal . a:1
"		endfunction
"	ローカルスコープ
"		function! s:AnimalGreeting(animal, ...)
"			echo a:animal . a:1
"		endfunction
"		s:を付けることを習慣にしたい(定義ファイル以外からの隠蔽)。
"		他の人の関数を上書きする可能性があることも考慮すること。
" ・クラス
"	サポートはないが、辞書にメソッドを持つことが出来るため、オブジェクト指向パラダイムが利用可能になる(どういう意味？)。
"		let animal_names = {
"			\ 'cat': 'Miss Cattington',
"			\ 'dog': 'Mr Dogson',
"			\ 'parrot': 'Polly'
"			\}
"		function animal_names.GetHighlight(animal)
"			return self[a:animal]	←selfで辞書のキーを参照する。
"		endfunction
"	別回答
"		let animals = {
"			animal_names = {
"				\ 'cat': 'Miss Cattington',
"				\ 'dog': 'Mr Dogson',
"				\ 'parrot': 'Polly'
"			\ }
"		\ }
"		function GetHighlight(animal) dict
"			return self.animal_names[a:animal]
"		endfunction
"		let animals['GetGreeting'] = function('GetGreeting')
"		呼び出し：
"			echo animals.GetGreeting('dog')
" ・ラムダ式(無名関数)
"	let AnimalGreeting = {animal -> animal }
"	echo AnimalGreeting('cat')
" ・マップとフィルタ(関数を操作する関数)
"	function! IsProperName(name)
"		if a:name =~? '\(Mr\|Miss|) .\+'
"			return 1
"		endif
"		return 0
"	endfunction
"
"	呼び出し
"		call filter(animal_names, 'IsProperName(v:val)')
"		echo animal_names
"



" ■vimgrep
"	https://qiita.com/yuku_t/items/0c1aff03949cb1b8fe6b
"	※grepの簡易版？
"	書　式：:vimgrep <パターン> <Path>
"	別書式：:vim[grep] {pattern} {file} ...
"		マッチ移動：cn・cp
"		Quickfixリスト：copen
"	{file} ...で指定したファイルの中から{pattern}で一致する箇所を検索する。
"
"	カレントバッファを対象としたvimgrep方法。
"		:vim {pattern} %

" ■ジャンプ
"	gd：変数の宣言場所にジャンプする(ローカル変数)。
"	gD：変数の宣言場所にジャンプする(グローバル変数)。
"	gf：ファイルの宣言場所にジャンプする。
"
" ○CtrlPプラグイン
"	Ctrl+f：検索対象をファイルにする。
"	Ctrl+b：検索対象をバッファにする。
"	Ctrl+d：フルPath検索もしくはファイル名検索の切り替え。
"	Ctrl+\：レジスタ貼り付けモード起動
"	Ctrl+z：マーク付け。
"	Ctrl+y：ファイル作成
"

" ■レジスタ
"	"記号を使い分けることで数回前の内容を使い回せる
"		例えば、7回前の削除単語を貼り付ける場合、	"7p	でペーストできる(全部で10回分を保持している)。
"	"*p：パソコンからのクリップボードを貼り付けられる。
"	"*yw：vimからパソコンのクリップボードにヤンクできる。
"	レジスタ一覧
"		:reg


" ■Git
" git branch
"	ブランチの一覧が表示され、現在地も示す。
"	オプション
"		-a	リモートブランチを含めて表示する。
"		-v	詳細情報を付与
"		-vv	リモートブランチを含める。
" git checkout [ブランチ名]
"	ブランチの切り替えを行う。
"	git checkout -b another_fix_branch fixing_readme
"	例）git checkout -b [新規ブランチ名] [既存ブランチ名]
"	他オプション
"		-b	既存ブランチから新規ブランチを作成後、ブランチ切り替えまで行う。
"		-m	ブランチ名の変更。
"		-d [既存ブランチ名]	ブランチの削除
"		-D	強制削除
"		-u	現在のブランチを指定リモートブランチに紐付ける。
"
" 例）
"	[asakunotomohiro@gitMachine dotfiles] $ git branch 
"	* master
"	[asakunotomohiro@gitMachine dotfiles] $ git branch -v
"	* master bd9bd96 [ahead 1] AutoHotKeyの移動
"	[asakunotomohiro@gitMachine dotfiles] $ git branch -a
"	* master
"	remotes/origin/master
"	[asakunotomohiro@gitMachine dotfiles] $

" 〇	vim-GitGutterプラグイン
"	<Leader>hs：ハンク部分のステージング
"				以下の定義で、ステージング方法を追加。
"	<Leader>hu：ハンク部分のステージングを取り消す。
"	<Leader>hp：ハンク部分のプレビュー(変更前の状態と比較)
"	]c：押下により、次のハンク(変更点のかたまり)
"	[c：押下により、前のハンクへ移動
"	ic：オペレータ待ちモードでの・・・。
"	ac：オペレータ待ちモードでの・・・。
"	ic：ビジュアルモードでの・・・。
"	ac：ビジュアルモードでの・・・。
"
" 〇	vim-fugitiveプラグイン
"		使うには、何かしらの権限が必要なようで、PullやPushができないままになっている。
"<leader>gs	:Gstatus
"	ステータス。
	" s：ステージ(add)する。
	" -：git ステージング切り替え
	" u：ステージした物を取り除く(undo)
	" =：ウィンドウ内に差分を表示(diffをその場で開く)
	" D：diffウィンドウを並べて出してくれる
	" dv：diffのvisual(下ペインで開く)
	" <Enter>：編集する
	" X：変更を取り消す
	" 以下、コミット操作
	" cc：コミット
	" ca：直前のコミットを変更する形でコミットする(git commit --amend)
	" ce：査前のコミットを変更する形でコミットするが、コミットメッセージを変更しない(git commit --amend --no-edit)
	" cw：査前のコミットのコミットメッセージのみを変更する。
	" cvc：verboseモードでコミットする(git commit -v)
	" cf：fixup!でコミットする(git commit --fixup=)これを実行して査後に<Tab><Enter>押下後HEADにfixupする。
" <leader>ga		git add
" <leader>gc		git commit
" <leader>gb		git blame	:Gblame	記録の遡り(行との変更確認や変更日時や変更者の確認)
	" 行ごとに最終コミットされた時期・誰かを一覧にする。
"alias logall='log --graph --pretty=format:\'%Cred%h %Cgreen(%>(15,trunc)%cr, %ci) %C(bold blue)<%an>%Creset -%C(yellow)%d%Creset %s\' --abbrev-commit --date=relative --all'
" <leader>gl		git log
" <leader>gh		変更履歴(架空コマンドgit history)
"					abbrev for `git history`: create new quickfix tab for history
" <leader>gp		git push
" <leader>gll		git pull
" <leader>gf		git fetch
" <leader>gd	diff	<Leader>gsのdvと同じ
" <leader>gr		git rebase -i	※リベースとは？スカッシュとは？　過去コミットを統合すると思って良い？
" <leader>gg		gitgrep
" <leader>gm		git merge
" :Glog	ログ
" :Glog --oneline	ログ
" :Gdiff [コミット番号]	差分
" :Gbrowse	現在のファイルをブラウザ内のオプションの行選択で開くことが出来る。
"			Shift-Vで表示したい行を選択します。あとは :Gbrowseを入力し、開いたページのURLをGitHubのPull RequestやIssueに貼る。
" :Gread	今開いてるファイルを最新のcommitの状態に戻す

"	□Android用。
"	〇Gboard
"		DroidVimの「設定」→「ファンクションバーモード」→「"abc"ボタン」→「<C-^>」
"		⇒完全に日本語入力の切り替えが可能になる。しかし、物理キーボード制御は無理だった。
" `<C-^>`で英数/通常入力の切り替えと[Shift]+[Space]を自動実行
let g:imactivate_language_switch = 61

"
"	〇DroidVim
" Input mode : 50 (Default) 51-53 (Disable word prediction)
"let s:ImeNormal = 53
"let s:ImeInsert = 50
"augroup ATEModIME
"	au!
"	au InsertEnter * call IMCtrl('On')
"	au InsertLeave * call IMCtrl('Off')
"	au VimEnter    * call IMCtrl('VimEnter')
"augroup END
"function! IMCtrl(cmd)
"	let cmd = a:cmd
"	if cmd == 'On'
"		call s:ATEMod(s:ImeInsert)
"	elseif cmd == 'Off'
"		call s:ATEMod(s:ImeNormal)
"	elseif cmd == 'Toggle'
"		call s:ATEMod(55)
"	elseif cmd == 'VimEnter'
"		call s:ATEMod(s:ImeNormal)
"	endif
"	return ''
"endfunction
"function! s:ATEMod(cmd)
"	let cmd = printf('echo -n -e "\0033[%st"', a:cmd)
"	exe 'silent !'.cmd
"endfunction


" 以上。
